======================================================================================================================

I - Project goal and concept

This project implements audio signal processing via an MFCC pipeline (Mel-Frequency Cepstral Coefficients).
The idea is to transform a signal through MFCC processing into a compact representation (a coefficient vector)
ready for further analysis (e.g., classification, clustering, sound detection, etc.).

The implementation is modular: each processing stage (windowing, FFT, Mel, DCT) is separated, making it easy
to follow and test each component independently.

======================================================================================================================

II - Project architecture

Project structure (most important folders):

1) include/
===============================================================================================================================

I - Project goal and concept

This project implements audio signal processing via an MFCC pipeline (Mel-Frequency Cepstral Coefficients).
The idea is to transform a signal through MFCC processing into a compact representation (a coefficient vector) ready for further analysis (e.g., classification, clustering, sound detection, etc.).

The implementation is modular: each processing stage (windowing, FFT, Mel, DCT) is separated, making it easy
to follow and test each component independently.

===============================================================================================================================

II - Project architecture

Project structure (most important folders):

1) include/

    a) include/core/
        - Structures representing inputs/outputs of DSP stages.
        - Frame<N> is the input frame (N samples), and Spectre<N> is the FFT output.
        - types.hpp contains types/constants needed for processing.

    b) include/dsp/
        - DSP step implementations:
          - window.hpp (Hann/Hamming windowing)
          - fft.hpp (FFT transform)
          - mel.hpp (Mel filter bank + normalization)
          - helpers.hpp (helper functions: power_spectrum, log_compression, dct, ...)
        - Note: the logic is organized through classes and helper functions (not a strict approach).

    c) include/features/
        - Higher-level (feature) module that combines steps into a single pipeline.
        - MFCCPipeline<N> performs:
          1) windowing (Hann)
          2) FFT
          3) power spectrum
          4) Mel filter bank
          5) log compression
          6) DCT (as implemented in dsp/helpers)

2) tests/
    - Simple executable tests that check behavior of individual components:
      - fft_test: FFT verification
      - window_test: Hann/Hamming window verification
      - pipeline_test: end-to-end MFCC pipeline verification on various signals (sine, sum of sines, zero,
        impulse, ramp, DC and white noise).

3) bindings/
    - Pybind11 bindings that generate the Python module reson from the C++ code.
    - The module is organized into submodules:
      - reson.core (Frame128/256/512/1024, Spectre...)
      - reson.dsp (Window..., FFT..., MelFilterBank, WindowType)
      - reson.features (MFCCPipeline128/256/512/1024)

4) build/
    - Out-of-source build directory (generated by CMake).

5) example.py
    - Example usage of the Python module: generates a 440 Hz sine, runs the MFCC pipeline, and prints coefficients.

===============================================================================================================================

III - Implementation

The MFCC pipeline is implemented as a generic class MFCCPipeline<N> (header-only), where N is the input frame
size (e.g., 128/256/512/1024). The pipeline operates on a single frame instance and returns a vector of MFCC
coefficients (std::vector<float>).

Processing flow (conceptually, per call to process(frame)):

1) Windowing
    - The input Frame<N> is multiplied by a window function (default: Hann).
    - The window reduces spectral leakage before the FFT.

2) FFT
    - From the windowed frame, Spectre<N> (complex spectrum) is computed.

3) Power spectrum
    - The power spectrum is computed from the complex spectrum.
    - Typically only the positive spectrum is used (N/2 + 1 bins).

4) Mel filter bank
    - The power spectrum is projected onto the Mel scale using triangular filters.
    - Parameters: sample_rate, n_fft, n_mels, fmin_hz, fmax_hz.
    - If fmax_hz = -1, it is automatically set to the Nyquist frequency (sample_rate/2).

5) Log compression
    - log(·) is applied to Mel energies (dynamic range compression).

6) DCT
    - DCT is applied to log-Mel energies and the first n_mfcc coefficients are kept.

Parameters controlled by the user: 
    - sample_rate: signal sampling frequency 
    - n_mels: number of Mel filters 
    - n_fft: FFT buffer size (recommendation: n_fft == N) 
    - n_mfcc: number of output MFCC coefficients 
    - fmin_hz, fmax_hz: lower/upper frequency (Hz)

Assumptions and limitations (intentionally minimal pipeline):
    - The pipeline works on a single frame; it does not automatically perform framing, overlap/hop, or full-signal processing.
    - No pre-emphasis, liftering, or delta/delta-delta coefficients.
    - If MFCCs are needed for an entire signal, the signal must first be split into frames (with a hop) and
      process (frame) must be called for each frame.

===============================================================================================================================

IV - How to use

1) Dependencies

Option A (automatically):
    - Run setup.sh (installs cmake, compiler toolchain, python3-dev, and pybind11).

Option B (manually):
    - Required: CMake >= 3.20, a C++17 compiler (g++/clang++), Python3 + python3-dev, pybind11.

2) Build (from project root)

    mkdir -p build
    cd build
    cmake ..
    make -j

Build result:
    - test executables: fft_test, window_test, pipeline_test
    - Python module: reson*.so (name depends on the Python version and platform)

3) Running tests

    cd build
    ./fft_test
    ./window_test
    ./pipeline_test

4) Usage from Python

The simplest way is to run the example script so Python can see the build/ directory:
    - from the project root: python3 example.py (the script adds build/ to sys.path)
    - or from the build directory: python3 ../example.py

Alternatives (manual):
    - export PYTHONPATH="$PWD/build:$PYTHONPATH"
    - python3 example.py

5) Quick API overview (Python)

    - Frame (e.g., 512 samples):
            frame = reson.core.Frame512()
            frame[i] = ...

    - Pipeline:
            mfcc = reson.features.MFCCPipeline512(
                    sample_rate=16000,
                    n_mels=40,
                    n_fft=512,
                    n_mfcc=13,
                    fmin_hz=0,
                    fmax_hz=-1
            )
            coeffs = mfcc.process(frame)

Notes:
    - Recommended: n_fft should match the frame size (e.g., Frame512 with n_fft=512), since the FFT is computed over N samples.
    - fmax_hz=-1 means it is automatically set to the Nyquist frequency (sample_rate/2).

===============================================================================================================================

    a) include/core/
        - Structures representing inputs/outputs of DSP stages.
        - Frame<N> is the input frame (N samples), and Spectre<N> is the FFT output.
        - types.hpp contains types/constants needed for processing.

    b) include/dsp/
        - DSP step implementations:
          - window.hpp (Hann/Hamming windowing)
          - fft.hpp (FFT transform)
          - mel.hpp (Mel filter bank + normalization)
          - helpers.hpp (helper functions: power_spectrum, log_compression, dct, ...)
        - Note: the logic is organized through classes and helper functions (not a strict singleton approach).

    c) include/features/
        - Higher-level (feature) module that combines steps into a single pipeline.
        - MFCCPipeline<N> performs:
          1) windowing (Hann)
          2) FFT
          3) power spectrum
          4) Mel filter bank
          5) log compression
          6) DCT (as implemented in dsp/helpers)

2) tests/
    - Simple executable tests that check behavior of individual components:
      - fft_test: FFT verification
      - window_test: Hann/Hamming window verification
      - pipeline_test: end-to-end MFCC pipeline verification on various signals (sine, sum of sines, zero,
        impulse, ramp, DC and white noise).

3) bindings/
    - Pybind11 bindings that generate the Python module reson from the C++ code.
    - The module is organized into submodules:
      - reson.core (Frame128/256/512/1024, Spectre...)
      - reson.dsp (Window..., FFT..., MelFilterBank, WindowType)
      - reson.features (MFCCPipeline128/256/512/1024)

4) build/
    - Out-of-source build directory (generated by CMake).

5) example.py
    - Example usage of the Python module: generates a 440 Hz sine, runs the MFCC pipeline, and prints coefficients.

======================================================================================================================

III - Implementation

The MFCC pipeline is implemented as a generic class MFCCPipeline<N> (header-only), where N is the input frame
size (e.g., 128/256/512/1024). The pipeline operates on a single frame instance and returns a vector of MFCC
coefficients (std::vector<float>).

Processing flow (conceptually, per call to process(frame)):

1) Windowing
    - The input Frame<N> is multiplied by a window function (default: Hann).
    - The window reduces spectral leakage before the FFT.

2) FFT
    - From the windowed frame, Spectre<N> (complex spectrum) is computed.

3) Power spectrum
    - The power spectrum is computed from the complex spectrum.
    - Typically only the positive spectrum is used (N/2 + 1 bins).

4) Mel filter bank
    - The power spectrum is projected onto the Mel scale using triangular filters.
    - Parameters: sample_rate, n_fft, n_mels, fmin_hz, fmax_hz.
    - If fmax_hz = -1, it is automatically set to the Nyquist frequency (sample_rate/2).

5) Log compression
    - log(·) is applied to Mel energies (dynamic range compression).

6) DCT
    - DCT is applied to log-Mel energies and the first n_mfcc coefficients are kept.

Parameters controlled by the user:
    - sample_rate: frekvencija odabiranja signala
    - n_mels: broj Mel filtera
    - n_fft: velicina FFT bafera (preporuka: n_fft == N)
    - n_mfcc: broj izlaznih MFCC koeficijenata
    - fmin_hz, fmax_hz: donja/gornja frekvencija (Hz)

Assumptions and limitations (intentionally minimal pipeline):
    - The pipeline works on a single frame; it does not automatically perform framing, overlap/hop, or full-signal processing.
    - No pre-emphasis, liftering, or delta/delta-delta coefficients.
    - If MFCCs are needed for an entire signal, the signal must first be split into frames (with a hop) and
      process (frame) must be called for each frame.

======================================================================================================================

IV - How to use

1) Dependencies

Option A (automatically):
    - Run setup.sh (installs cmake, compiler toolchain, python3-dev, and pybind11).

Option B (manually):
    - Required: CMake >= 3.20, a C++17 compiler (g++/clang++), Python3 + python3-dev, pybind11.

2) Build (from project root)

    mkdir -p build
    cd build
    cmake ..
    make -j

Build result:
    - test executables: fft_test, window_test, pipeline_test
    - Python module: reson*.so (name depends on the Python version and platform)

3) Running tests

    cd build
    ./fft_test
    ./window_test
    ./pipeline_test

4) Usage from Python

The simplest way is to run the example script so Python can see the build/ directory:
    - from the project root: python3 example.py (the script adds build/ to sys.path)
    - or from the build directory: python3 ../example.py

Alternatives (manual):
    - export PYTHONPATH="$PWD/build:$PYTHONPATH"
    - python3 example.py

5) Quick API overview (Python)

    - Frame (e.g., 512 samples):
            frame = reson.core.Frame512()
            frame[i] = ...

    - Pipeline:
            mfcc = reson.features.MFCCPipeline512(
                    sample_rate=16000,
                    n_mels=40,
                    n_fft=512,
                    n_mfcc=13,
                    fmin_hz=0,
                    fmax_hz=-1
            )
            coeffs = mfcc.process(frame)

Notes:
    - Recommended: n_fft should match the frame size (e.g., Frame512 with n_fft=512), since the FFT is computed over N samples.
    - fmax_hz=-1 means it is automatically set to the Nyquist frequency (sample_rate/2).

======================================================================================================================
